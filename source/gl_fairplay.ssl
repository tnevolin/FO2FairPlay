/*

FairPlay mod for fallout 2 by Bear
----------------------------------------

Requires sfall 4.3.0.2 +

*/


#include "ITEMPID.H"
#include "sfall.h"
#include "lib.math.h"
#include "lib.arrays.h"
#include "define_lite.h"
#include "define_extra.h"

#define NAME "gl_fairplay"
#define ndebug(message) debug_msg(NAME + ": " + message)

// constants

#define SKILL_RATE_BASE (15)

#define WEAPON_MINST_DAMAGE_MULTIPLIER (1.00)
#define WEAPON_MINST_DAMAGE_SQRT_MULTIPLIER (1.30)
#define WEAPON_MINST_DAMAGE_SQRT_MULTIPLIER_GRENADE_MODIFIER (0.30)
#define WEAPON_MINST_BURST_DIVIDER (8)

variable fractionalAP = 0.0;
variable accumulatedFractionalAP = 0.0;
variable carryoverAP = 0;
variable ammoPids;

procedure handleCombatTurn;
procedure handleUseObject;
procedure handleDescriptionObject;
procedure handleToHit;
procedure setFractionalAP;
procedure modifyAmmoACMod;
procedure modifyWeaponMinST;

procedure item_w_subtype(variable weapon, variable attackMode);

procedure start begin
	if game_loaded then begin

		// hooks

		register_hook_proc(HOOK_COMBATTURN, handleCombatTurn);
		register_hook_proc(HOOK_USEOBJ, handleUseObject);
		register_hook_proc(HOOK_DESCRIPTIONOBJ, handleDescriptionObject);
		register_hook_proc(HOOK_TOHIT, handleToHit);

		// fractional AP

		call setFractionalAP();

		// ammo AC mod

		call modifyAmmoACMod;

		// SP rate

		mod_skill_points_per_level(SKILL_RATE_BASE - get_pc_base_stat(STAT_iq));

		// weapon min ST

		call modifyWeaponMinST;

	end
end

procedure handleCombatTurn begin
	variable stage = get_sfall_arg;
	variable critter = get_sfall_arg;

	// dude

	if (critter != dude_obj) then
		return;

	// turn begins

	if (stage == 1) then
		begin

			// add fractionalAP

			accumulatedFractionalAP += fractionalAP;
			variable wholeAccumulatedFractionalAP = floor(accumulatedFractionalAP);
			accumulatedFractionalAP -= wholeAccumulatedFractionalAP;

			set_critter_current_ap(critter, get_critter_current_ap(critter) + wholeAccumulatedFractionalAP);

			// add carryoverAP

			set_critter_current_ap(critter, get_critter_current_ap(critter) + carryoverAP);

		end

	// turn ends

	else if (stage == 0) then
		begin

			// set carryoverAP for next round

			carryoverAP = MIN(3, get_critter_current_ap(critter));

		end

	// combat ends

	else
		begin

			// reset fractionalAP

			fractionalAP = 0.0;

			// reset carryoverAP

			carryoverAP = 0;

		end

end

procedure handleUseObject begin

	ndebug("handleUseObject");

	variable user = get_sfall_arg;
	variable object = get_sfall_arg;

	// dude uses book

	if (not (user == dude_obj and obj_type(object) == OBJ_TYPE_ITEM and obj_item_subtype(object) == item_type_misc_item)) then
		return;

	ndebug("book: " + obj_name(object));

	// get object pid

	variable pid = obj_pid(object);

	// populate book variables

	variable bookSkillMessages = temp_array_map;

	switch (pid) begin
		case PID_BIG_BOOK_OF_SCIENCE :
			begin
				bookSkillMessages[SKILL_SCIENCE] = mstr_proto(802);
				bookSkillMessages[SKILL_DOCTOR] = "You review scientific breakthrough in medicine.";
				bookSkillMessages[SKILL_GAMBLING] = "You memorize gambling algorithm.";
				bookSkillMessages[SKILL_CONVERSANT] = "You pick buzzwords to use in conversation.";
			end
		case PID_DEANS_ELECTRONICS :
			begin
				bookSkillMessages[SKILL_REPAIR] = mstr_proto(803);
				bookSkillMessages[SKILL_ENERGY_WEAPONS] = "You copy energy weapon circuits schematics.";
				bookSkillMessages[SKILL_LOCKPICK] = "You review electronic lock bypass method.";
				bookSkillMessages[SKILL_CONVERSANT] = "You pick buzzwords to use in conversation.";
			end
		case PID_FIRST_AID_BOOK :
			begin
				bookSkillMessages[SKILL_FIRST_AID] = mstr_proto(804);
				bookSkillMessages[SKILL_UNARMED_COMBAT] = "You learn stamina strengthening exercise.";
				bookSkillMessages[SKILL_MELEE] = "You study vulnerable body spots.";
				bookSkillMessages[SKILL_DOCTOR] = "You refresh your basic medical training skills.";
				bookSkillMessages[SKILL_CONVERSANT] = "You pick buzzwords to use in conversation.";
			end
		case PID_SCOUT_HANDBOOK :
			begin
				bookSkillMessages[SKILL_OUTDOORSMAN] = mstr_proto(806);
				bookSkillMessages[SKILL_UNARMED_COMBAT] = "You copy body building recipie.";
				bookSkillMessages[SKILL_MELEE] = "You learn few streat fight dirty tricks.";
				bookSkillMessages[SKILL_SNEAK] = "You refine you camouflage skill.";
				bookSkillMessages[SKILL_LOCKPICK] = "You practice picking crude mechanical locks.";
				bookSkillMessages[SKILL_STEAL] = "You learn tactical stealing.";
			end
		case PID_GUNS_AND_BULLETS :
			begin
				bookSkillMessages[SKILL_SMALL_GUNS] = mstr_proto(805);
				bookSkillMessages[SKILL_BIG_GUNS] = mstr_proto(805);
				bookSkillMessages[SKILL_ENERGY_WEAPONS] = mstr_proto(805);
				bookSkillMessages[SKILL_FIRST_AID] = "You study bullet wounds first aid.";
				bookSkillMessages[SKILL_CONVERSANT] = "You enrich your vocabulary with gun fight terms.";
			end
		case 635 /* Traps and Explosives */ :
			begin
				bookSkillMessages[SKILL_TRAPS] = mstr_proto(807);
				bookSkillMessages[SKILL_THROWING] = "You learn better grenades and explosives handling.";
				bookSkillMessages[SKILL_CONVERSANT] = "You enrich your vocabulary with trapping terms.";
			end
		case 636 /* Capital */ :
			begin
				bookSkillMessages[SKILL_BARTER] = mstr_proto(808);
				bookSkillMessages[SKILL_STEAL] = "You learn how to steal without breaking the law.";
				bookSkillMessages[SKILL_CONVERSANT] = "You enrich your vocabulary with economics terms.";
			end
		default :
			return;
	end

	// select target skill

	variable selectedSkill = -1, selectedSkillLevel;
	variable skill, message;
	foreach (skill : message in bookSkillMessages)
		begin
			variable skillLevel = get_critter_skill_points(dude_obj, skill);
			if (selectedSkill == -1 or skillLevel < selectedSkillLevel) then
				begin
					selectedSkill = skill;
					selectedSkillLevel = skillLevel;
				end
		end

	// selected skill not found

	if (selectedSkill == -1) then
		return;

	// add to skill

	ndebug("skill: " + mstr_skill(100 + selectedSkill));

	// get additional skill points

	variable initalAdditionalSkillLevel = get_critter_skill_points(dude_obj, selectedSkill);
	variable additionalSkillLevel = initalAdditionalSkillLevel;

	// compute skill progression

	variable remainedBookAvailableSkillPoints = 6;
	if (has_trait(TRAIT_PERK, dude_obj, PERK_comprehension_perk)) then
		begin
			remainedBookAvailableSkillPoints *= 3;
			remainedBookAvailableSkillPoints /= 2;
		end

	while (true) do
		begin

			variable skillLevelAdvancementCost = min(6, additionalSkillLevel / 25 + 1);

			if (remainedBookAvailableSkillPoints >= skillLevelAdvancementCost) then
				begin
					additionalSkillLevel++;
					remainedBookAvailableSkillPoints -= skillLevelAdvancementCost;
				end
			else
				break;

		end

	set_critter_skill_points(dude_obj, selectedSkill, additionalSkillLevel);
	set_available_skill_points(get_available_skill_points + remainedBookAvailableSkillPoints);

	// display messages

	display_msg(bookSkillMessages[selectedSkill]);
	display_msg("[" + mstr_skill(100 + selectedSkill) + " +" + (additionalSkillLevel - initalAdditionalSkillLevel) + "/" + remainedBookAvailableSkillPoints + "]");

	set_sfall_return(1);

	// advance time

	game_time_advance(6 * ONE_GAME_HOUR);

	debug_msg("");

end

procedure handleDescriptionObject begin

	variable object = get_sfall_arg;

	// weapon

	if (not (obj_type(object) == OBJ_TYPE_ITEM and obj_item_subtype(object) == item_type_weapon)) then
		return;

	// modify Min ST

	variable pid = obj_pid(object);
	variable minST = get_proto_data(pid, PROTO_WP_MIN_ST);
	variable descriptionMessageId = get_proto_data(pid, PROTO_TEXTID) + 1;
	variable descriptionMessage = message_str_game(GAME_MSG_PRO_ITEM, descriptionMessageId);
	variable descriptionMessageSplit = string_split(descriptionMessage, " Min ST:");
	variable descriptionMessageModified = descriptionMessageSplit[0] + " Min ST: " + minST + ".";

	// add weapon perk description

	variable weaponPerk = get_proto_data(pid, PROTO_WP_PERK);

	if (weaponPerk == PERK_weapon_accurate) then
		descriptionMessageModified += " (accurate).";
	else if (weaponPerk == PERK_weapon_long_range) then
		descriptionMessageModified += " (long range).";
	else if (weaponPerk == PERK_weapon_scope_range) then
		descriptionMessageModified += " (scope range).";

	// return modified description

	set_sfall_return(get_string_pointer(descriptionMessageModified));

end

procedure handleToHit
begin

	ndebug("handleToHit");

	variable hitChanceCapped = get_sfall_arg;
	variable attacker = get_sfall_arg;
	variable target = get_sfall_arg;
	variable targettedBodypart = get_sfall_arg;
	variable sourceTile = get_sfall_arg;
	variable attackType = get_sfall_arg;
	variable ranged = get_sfall_arg;
	variable hitChanceRaw = get_sfall_arg;
	variable hitChanceCappedModified;
	variable hitChanceRawModified;

	debug_msg("hitChance (vanilla) = " + hitChanceRaw);
	if (target != 0) then
		debug_msg("target AC = " + get_critter_stat(target, STAT_ac));

	// weapon

	variable weaponInventorySpot;
	if (attacker == dude_obj) then
		weaponInventorySpot = INVEN_TYPE_LEFT_HAND - active_hand;
	else
		weaponInventorySpot = INVEN_TYPE_RIGHT_HAND;

	variable weapon = critter_inven_obj(attacker, weaponInventorySpot);

	if (weapon == 0) then
		return;

	variable weaponAttackType = item_w_subtype(weapon, attackType);
	variable rangedAttack = (weaponAttackType == WEAPON_TYPE_GUNS or weaponAttackType == WEAPON_TYPE_THROWN);

	if (not rangedAttack) then
		return;

	// remove PE, weapon perk, sharpshooter, and distance effects

	variable weaponPid = obj_pid(weapon);
	variable weaponPerk = get_proto_data(weaponPid, PROTO_WP_PERK);
	variable dist_mod1 = 0, dist_mod2 = 0;
	variable statPE = get_critter_stat(attacker, STAT_pe);
	variable distance;
	variable distanceModifier = 0;
	variable distanceModified = 0;

	debug_msg("statPE = " + statPE);

	if (weaponPerk == PERK_weapon_long_range) then
		begin
			debug_msg("weapon perk = long range");
			dist_mod1 = 4;
		end
	else if (weaponPerk == PERK_weapon_scope_range) then
		begin
			debug_msg("weapon perk = scope range");
			dist_mod1 = 5;
			dist_mod2 = 8;
		end
	else
		begin
			debug_msg("weapon perk = none");
			dist_mod1 = 2;
		end

	debug_msg("dist_mod1 = " + dist_mod1);
	debug_msg("dist_mod2 = " + dist_mod2);

	if (target == 0) then
		begin
			distance = 0;
		end
	else
		begin
			distance = tile_distance(sourceTile, tile_num(target));
		end
	distanceModified = distance;

	debug_msg("distance (initial) = " + distanceModified);

	if (distance >= dist_mod2) then
		begin
			if (attacker == dude_obj) then
				begin
					distanceModifier = - dist_mod1 * (statPE - 2);
				end
			else
				begin
					distanceModifier = - dist_mod1 * (statPE);
				end
		end
	else
		begin
			distanceModifier = dist_mod2;
		end

	distanceModified += distanceModifier;

	debug_msg("distanceModifier = " + distanceModifier);
	debug_msg("distance (modified) = " + distanceModified);

	distanceModified = max( - (2 * statPE), distanceModified);

	debug_msg("distance (capped) = " + distanceModified);

	if (attacker == dude_obj and has_trait(TRAIT_PERK, attacker, PERK_sharpshooter)) then
		begin
			distanceModified -= 4;
		end

	debug_msg("distance (sharpshooter) = " + distanceModified);

	hitChanceRawModified = hitChanceRaw - (-4 * distanceModified);

	debug_msg("hitChance (without PE/perk/ss/dist) = " + hitChanceRawModified);

	// apply PE, weapon perk, sharpshooter, and distance *modified* effects

	variable effectiveRange1 = 0;
	variable effectiveRange2 = statPE;
	variable effectiveRangeShift = 0;

	if (attacker == dude_obj and has_trait(TRAIT_PERK, attacker, PERK_sharpshooter)) then
		begin
			effectiveRange2 += 4;
		end

	if (weaponPerk == PERK_weapon_long_range) then
		begin
			effectiveRangeShift = 10;
		end
	else if (weaponPerk == PERK_weapon_scope_range) then
		begin
			effectiveRangeShift = 15;
		end

	effectiveRange1 += effectiveRangeShift;
	effectiveRange2 += effectiveRangeShift;

	debug_msg("effectiveRange1 = " + effectiveRange1);
	debug_msg("effectiveRange2 = " + effectiveRange2);

	variable rangePenalty;

	if (distance > effectiveRange2) then
		begin
			rangePenalty = (-4) * (distance - effectiveRange2);
		end
	else if (distance < effectiveRange1) then
		begin
			rangePenalty = (-4) * (effectiveRange1 - distance);
		end
	else
		begin
			rangePenalty = 0;
		end

	debug_msg("rangePenalty = " + rangePenalty);

	hitChanceRawModified += rangePenalty;
	hitChanceCappedModified = min(95, hitChanceRawModified);

	debug_msg("hitChanceRawModified = " + hitChanceRawModified);
	debug_msg("hitChanceCappedModified = " + hitChanceCappedModified);

	// set hook variables

	set_sfall_arg(0, hitChanceCappedModified);
	set_sfall_arg(7, hitChanceRawModified);
	set_sfall_return(hitChanceCappedModified);

	debug_msg("");

end

procedure setFractionalAP
begin

	ndebug("setFractionalAP");

	variable derivedStatsIniFile = get_ini_string("ddraw.ini|Misc|DerivedStats");
	if (strlen(derivedStatsIniFile) == 0) then
		return;

	variable baseAPMin = atoi(get_ini_string(derivedStatsIniFile + "|8|" + "min"));
	variable baseAPbase = atoi(get_ini_string(derivedStatsIniFile + "|8|" + "base"));

	variable product = 0.0;

	variable stat;
	for (stat = STAT_st; stat <= STAT_lu; stat++)
	begin

		variable shift = atoi(get_ini_string(derivedStatsIniFile + "|8|" + "shift" + stat));
		variable multi = atof(get_ini_string(derivedStatsIniFile + "|8|" + "multi" + stat));

		product += (get_critter_stat(dude_obj, stat) + shift) * multi;

	end

	variable value = max(baseAPMin, baseAPBase + product);

	fractionalAP = value - floor(value);

	ndebug("fractionalAP=" + fractionalAP);
	debug_msg("");

end

procedure modifyAmmoACMod begin

	ndebug("Ammo: set AC mod = 0");

	// cycle through pids for ammo

	variable pid;
	for (pid = 1; pid < 2000; pid++) begin

		// ammo

		if (not (proto_data(pid, it_type) == item_type_ammo)) then
			continue;

		debug_msg(proto_data(pid, it_name));

		// clear AC mod

		set_proto_data(pid, PROTO_AM_AC_MOD, 0);

	end

	debug_msg("");

end

procedure modifyWeaponMinST begin

	ndebug("modifyWeaponMinST");

	// allow memory modification

	variable pid;
	for (pid = 1; pid < 2000; pid++)
	begin

		// weapon

		if (not (proto_data(pid, it_type) == item_type_weapon)) then
			continue;

		// calculate modifier for grenade

		variable weaponMinSTDamageSqrtMultiplier = WEAPON_MINST_DAMAGE_SQRT_MULTIPLIER;
		if (get_proto_data(pid, PROTO_WP_ANIM) == 0 and (get_proto_data(pid, PROTO_WP_PROJ_PID) == 83886105 or get_proto_data(pid, PROTO_WP_PROJ_PID) == 83886110)) then
			weaponMinSTDamageSqrtMultiplier *= WEAPON_MINST_DAMAGE_SQRT_MULTIPLIER_GRENADE_MODIFIER;

		// calculate min ST

		variable name = proto_data(pid, it_name);
		variable minSTOld = get_proto_data(pid, PROTO_WP_MIN_ST);
		variable averageDamage = (get_proto_data(pid, PROTO_WP_DMG_MIN) + get_proto_data(pid, PROTO_WP_DMG_MAX)) / 2;
		variable burst = get_proto_data(pid, PROTO_WP_BURST);
		variable minST = max(minSTOld, 1 + floor(sqrt(averageDamage * WEAPON_MINST_DAMAGE_MULTIPLIER) * weaponMinSTDamageSqrtMultiplier + burst / WEAPON_MINST_BURST_DIVIDER));

		set_proto_data(pid, PROTO_WP_MIN_ST, minST);

		variable message = name + ":";
		variable i;
		for (i = strlen(message); i < 26; i++)
		begin
			message += " ";
		end
		if (averageDamage < 10) then
			message += "  ";
		else if (averageDamage < 100) then
			message += " ";
		message += " " + averageDamage;
		if (burst < 10) then
			message += " ";
		message += " " + burst;
		if (minST < 10) then
			message += " ";
		message += " " + minST;
		debug_msg(message);

		variable flag;
		variable flagBitString;
		flag = get_proto_data(pid, PROTO_FLAG);
		flagBitString = "";
		for (i = 1; i <= 2 ^ 15; i *= 2)
		begin
			flagBitString = ((flag bwand i) != 0) + flagBitString;
		end
		debug_msg(flagBitString);
		flag = get_proto_data(pid, PROTO_FLAG_EXT);
		flagBitString = "";
		for (i = 1; i <= 2 ^ 15; i *= 2)
		begin
			flagBitString = ((flag bwand i) != 0) + flagBitString;
		end
		debug_msg(flagBitString);

	end

	debug_msg("");

end

procedure item_w_subtype(variable weapon, variable hit_mode) begin
   variable attack_mode, type := WEAPON_TYPE_UNARMED;

   if weapon and (hit_mode <= ATKTYPE_RWEP2) then begin
      attack_mode := (get_proto_data(obj_pid(weapon), PROTO_IT_FLAGS));

      if (hit_mode == ATKTYPE_LWEP2) or (hit_mode == ATKTYPE_RWEP2) then
         attack_mode := (attack_mode bwand 0xF0) / 16; // shift 4 bits to the right
      else
         attack_mode := (attack_mode bwand 0x0F);

      if (attack_mode > ATKMODE_PRI_THROW) then
         type := WEAPON_TYPE_GUNS;
      else if (attack_mode == ATKMODE_PRI_THROW) then
         type := WEAPON_TYPE_THROWN;
      else if (attack_mode > ATKMODE_PRI_KICK) then
         type := WEAPON_TYPE_MELEE;
   end

   return type;
end

